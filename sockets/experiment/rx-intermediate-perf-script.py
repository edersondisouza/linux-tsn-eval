# perf script event handlers, generated by perf script -g python
# Licensed under the terms of the GNU GPL License version 2

# The common_* event handler fields are the most useful fields common to
# all events.  They don't necessarily correspond to the 'common_*' fields
# in the format files.  Those fields not available as handler params can
# be retrieved using Python functions of the form common_*(context).
# See the perf-script-python Documentation for the list of available functions.

from __future__ import print_function
import os
import sys
import argparse
import csv

sys.path.append(os.environ['PERF_EXEC_PATH'] +
                '/scripts/python/Perf-Trace-Util/lib/Perf/Trace')

from Core import *
from perf_trace_context import *
from Util import nsecs

tstamp_core_data = []
tstamp_user_data = []

IRQ_HANDLER_ENTRY       = 0
NAPI_GRO_RECEIVE_ENTRY  = 1
NETIF_RECEIVE_SKB       = 2

last_irq_handler_entry_time = dict()
last_skbaddrs = dict()
tstamps_file = ''
iface_name = ''
tai_mono_offset = 0


def trace_begin():
    global tstamps_file, iface_name, tai_mono_offset

    parser = argparse.ArgumentParser()
    parser.add_argument('tstamps_file',
                        help='CSV file to store intermediate timestamps.')
    parser.add_argument('iface_name',
                        help='Interface name to track on events.')
    parser.add_argument('tai_mono_offset', type=int,
                        help='Offset between TAI and monotonic clocks.')
    args = parser.parse_args()
    tstamps_file = args.tstamps_file
    iface_name = args.iface_name
    tai_mono_offset = args.tai_mono_offset


def trace_end():
    header = ['irq_handler_entry',
              'napi_gro_receive_entry',
              'netif_receive_skb',
              'sys_exit_recvmsg']

    # As we're only expecting to run on Linux, and not sure if perf was built
    # with Python2 or Python3 support, it should be safe to open the file
    # for csv with just 'w'.
    with open(tstamps_file, 'w') as csvfile:
        writer = csv.writer(csvfile)

        writer.writerow(header)
        for (core_data, user_data) in zip(tstamp_core_data, tstamp_user_data):
            core_data.append(user_data)
            writer.writerow(core_data)


def irq__irq_handler_entry(event_name, context, common_cpu, common_secs,
                           common_nsecs, common_pid, common_comm,
                           common_callchain, irq, name, perf_sample_dict):
    last_irq_handler_entry_time[common_cpu] = nsecs(common_secs, common_nsecs) + tai_mono_offset


def syscalls__sys_exit_recvmsg(event_name, context, common_cpu, common_secs,
                               common_nsecs, common_pid, common_comm,
                               common_callchain, __syscall_nr, ret,
                               perf_sample_dict):
    if common_comm != 'tsn-listener' or ret < 0:
        return

    # Guard against duplicated entries - why do they happen?
    time = nsecs(common_secs, common_nsecs) + tai_mono_offset
    if len(tstamp_user_data) > 0 and tstamp_user_data[-1] == time:
        return

    tstamp_user_data.append(time)


def net__napi_gro_receive_entry(event_name, context, common_cpu, common_secs,
                                common_nsecs, common_pid, common_comm,
                                common_callchain, name, napi_id, queue_mapping,
                                skbaddr, vlan_tagged, vlan_proto, vlan_tci,
                                protocol, ip_summed, hash, l4_hash, length,
                                data_len, truesize, mac_header_valid,
                                mac_header, nr_frags, gso_size, gso_type,
                                perf_sample_dict):
    if name != iface_name or vlan_tagged != 1 or protocol != 0x22F0:
        return

    # XXX i saw some duplicated entries on perf report when running network
    # interference, this check accounts for that.
    # But, are there other duplicated entries somewhere?
    if skbaddr in last_skbaddrs.keys():
        return

    tstamp_core_data.append([0] * 3)
    tstamp_core_data[-1][IRQ_HANDLER_ENTRY] = last_irq_handler_entry_time[common_cpu]
    tstamp_core_data[-1][NAPI_GRO_RECEIVE_ENTRY] = nsecs(
        common_secs, common_nsecs) + tai_mono_offset

    last_skbaddrs[skbaddr] = len(tstamp_core_data) - 1


def net__netif_receive_skb(event_name, context, common_cpu, common_secs,
                           common_nsecs, common_pid, common_comm,
                           common_callchain, skbaddr, len, name,
                           perf_sample_dict):
    if skbaddr not in last_skbaddrs.keys():
        return

    i = last_skbaddrs[skbaddr]
    tstamp_core_data[i][NETIF_RECEIVE_SKB] = nsecs(common_secs, common_nsecs) + tai_mono_offset
    last_skbaddrs.pop(skbaddr)
