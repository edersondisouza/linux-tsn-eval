# perf script event handlers, generated by perf script -g python
# Licensed under the terms of the GNU GPL License version 2

# The common_* event handler fields are the most useful fields common to
# all events.  They don't necessarily correspond to the 'common_*' fields
# in the format files.  Those fields not available as handler params can
# be retrieved using Python functions of the form common_*(context).
# See the perf-script-python Documentation for the list of available functions.

from __future__ import print_function
import os
import sys
import argparse
import csv

sys.path.append(os.environ['PERF_EXEC_PATH'] +
                '/scripts/python/Perf-Trace-Util/lib/Perf/Trace')

from Core import *
from perf_trace_context import *
from Util import nsecs

tstamp_data = []

SYS_ENTER_SENDTO        = 0
NET_DEV_QUEUE_VLAN      = 1
NET_DEV_START_XMIT_VLAN = 2
NET_DEV_QUEUE           = 3
NET_DEV_START_XMIT      = 4
NET_DEV_XMIT            = 5
NET_DEV_XMIT_VLAN       = 6

active_skbaddr = dict()
tstamps_file = ''
iface_name = ''
tai_mono_offset = 0


def trace_begin():
    global tstamps_file
    global iface_name
    global tai_mono_offset

    parser = argparse.ArgumentParser()
    parser.add_argument('tstamps_file',
                        help='CSV file to store intermediate timestamps.')
    parser.add_argument('iface_name',
                        help='Physical interface used to transmit packets.')
    parser.add_argument('tai_mono_offset', type=int,
                        help='Offset between TAI and monotonic clocks.')
    args = parser.parse_args()
    tstamps_file = args.tstamps_file
    iface_name = args.iface_name
    tai_mono_offset = args.tai_mono_offset


def trace_end():
    header=['sys_enter_sendto',
            'net_dev_queue_vlan',
            'net_dev_start_xmit_vlan',
            'net_dev_queue',
            'net_dev_start_xmit',
            'net_dev_xmit',
            'net_dev_xmit_vlan']

    # As we're only expecting to run on Linux, and not sure if perf was built
    # with Python2 or Python3 support, it should be safe to open the file
    # for csv with just 'w'.
    with open(tstamps_file, 'w') as csvfile:
        writer = csv.writer(csvfile)

        writer.writerow(header)
        writer.writerows(tstamp_data)


# The arguments for this method are different between RT and non-RT kernels.
# Since we are not using any arguments which have been removed, they have been
# replaced with `*args`. If we need any arguments, we can extract them in the
# future.
def syscalls__sys_enter_sendto(event_name, context, common_cpu, common_secs,
                               common_nsecs, common_pid, common_comm,
                               common_callchain, __syscall_nr, *args):
    if common_comm != 'tsn-talker':
        return

    # Guard agains duplicated perf entries
    time = nsecs(common_secs, common_nsecs) + tai_mono_offset
    if len(tstamp_data) > 0 and tstamp_data[-1][SYS_ENTER_SENDTO] == time:
        return

    tstamp_data.append([0] * 7)
    tstamp_data[-1][SYS_ENTER_SENDTO] = time


def net__net_dev_queue(event_name, context, common_cpu,
                       common_secs, common_nsecs, common_pid, common_comm,
                       common_callchain, skbaddr, length, name, perf_sample_dict):
    global active_skbaddr

    if common_comm != 'tsn-talker' or name not in [iface_name, 'tsn_vlan']:
        return

    if skbaddr not in active_skbaddr.keys():
        active_skbaddr[skbaddr] = len(tstamp_data) - 1
        i = -1
    else:
        i = active_skbaddr[skbaddr]

    if name == iface_name:
        tstamp_data[i][NET_DEV_QUEUE] = nsecs(common_secs, common_nsecs) + tai_mono_offset
    else:
        tstamp_data[i][NET_DEV_QUEUE_VLAN] = nsecs(common_secs, common_nsecs) + tai_mono_offset


def net__net_dev_start_xmit(event_name, context, common_cpu,
                            common_secs, common_nsecs, common_pid, common_comm,
                            common_callchain, name, queue_mapping, skbaddr,
                            vlan_tagged, vlan_proto, vlan_tci, protocol,
                            ip_summed, len, data_len, network_offset,
                            transport_offset_valid, transport_offset, tx_flags,
                            gso_size, gso_segs, gso_type, perf_sample_dict):
    if skbaddr not in active_skbaddr.keys():
        return

    i = active_skbaddr[skbaddr]

    if name == iface_name:
        tstamp_data[i][NET_DEV_START_XMIT] = nsecs(common_secs, common_nsecs) + tai_mono_offset
    else:
        tstamp_data[i][NET_DEV_START_XMIT_VLAN] = nsecs(common_secs, common_nsecs) + tai_mono_offset


def net__net_dev_xmit(event_name, context, common_cpu,
                      common_secs, common_nsecs, common_pid, common_comm,
                      common_callchain, skbaddr, len, rc, name,
                      perf_sample_dict):
    global active_skbaddr

    if skbaddr not in active_skbaddr.keys():
        return

    i = active_skbaddr[skbaddr]

    if name == iface_name:
        tstamp_data[i][NET_DEV_XMIT] = nsecs(common_secs, common_nsecs) + tai_mono_offset

        if (tstamp_data[i][NET_DEV_QUEUE_VLAN] == 0 or
            tstamp_data[i][NET_DEV_XMIT_VLAN] != 0):
            active_skbaddr.pop(skbaddr)
    else:
        tstamp_data[i][NET_DEV_XMIT_VLAN] = nsecs(common_secs, common_nsecs) + tai_mono_offset

        if tstamp_data[i][NET_DEV_XMIT] != 0:
            active_skbaddr.pop(skbaddr)
